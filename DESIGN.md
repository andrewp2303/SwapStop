Our project was designed with two primary goals: being developed collaboratively on Github and implemented such that users can use SwapStop intuitively and quickly. In order to fulfill the first goal, we chose languages we were already familiar with through CS50 Finance (namely HTML/CSS/JS, Flask, and SQL) but also switched our database system to SQLAlchemy in order to become independent of CS50/Codespaces. In using SQLAlchemy, we were able to either use the SQL queries we’d learned in CS50 or alternatively use Python to create/query/modify our database.

In terms of database design, the overarching structure of our SQLAlchemy database entails three tables: users, items, and messages, corresponding to the User, Item, and Message types.

Each User entry has the columns id, username, password, first_name, last_name, and email, which correspond to the form users fill out when they register for SwapStop. We made sure to store passwords as a hash for user security, and we also had id set as the primary key so that we could quickly query through users / join it with other tables. 

Next, each Item has the columns id, name, description, img, datetime, sold, and user_id. The id column serves the same purpose of being a primary key, and name/description represent the text collected when listing an item. The img column does not actually store the image itself — rather, it stores the name of the image file, whose contents we access through the static/images folder. Storing images in static instead of our database was a key design choice that we made in order to make our website more efficient and easier to manage, while also better maintaining the quality/color of images that users submit. Datetime stores a DateTime value, which was automatically grabbed in Flask using the datetime.now() function, and then easily represented in Jinja using the datetime.strftime() function. Sold stores a boolean that tracks whether an item is available or unavailable, and finally user_id associates the owner of an item with the item itself, which was crucial for us while displaying items in Marketplace and My Items.

Finally, each Message has the columns id, sender_id, rec_id, timestamp, text, and item_id. Once again, id is a primary key, and sender_id and rec_id associate the users involved in the message through the use of a foreign key, which was very useful when displaying messages in myitem.html. Timestamp again stores a DateTime value, and text stores the contents of the message. Finally, item_id associates the item with messages sent about it, which was again crucial in collecting the messages for myitem.html.

The front end of our CS50 Final Project was the basis for the rest of our code. Starting with fundamental for-loops and if blocks in jinja, we created a basic display and scaffolding for the data that we would later implement. We used jinja for-loops to display the item cards that made up the html of viewitems.html and myitems.html, making these loops vital components of pages like “Marketplace.” We also made heavy use of Bootstrap components to style and create layouts for many pages. The use of bootstrap’s pre-made classes allowed us to create boxes(“containers”) which we utilized frequently in our placement of objects like inputs and labels. In addition to using Bootstrap components, we also built off a few of their example designs, most notably Album, which led to the construction of our Marketplace and My Items pages. However, in terms of styling, we found difficulty in importing styles.css from static, potentially because it conflicted with the imported Bootstrap stylesheets; as a result, our layout.html has a style element that stores specific stylistic changes we made for our website, such as making the background yellow and changing fonts. One final choice we made in the design of our html/front end was to store variables like items.id in values=””. This effectively allowed us to pass variables between each method/html template without having to rely on storing data in session, with which we found numerous potential risks.

Finally, the backend. Our main goal when designing the backend was to build off whatever we designed for our frontend. We consistently used “GET” requests when fetching a page, and we used “POST” requests whenever a form was submitted. This also helped us use the same route for two purposes, such as how the /viewitems route let us both render the marketplace and also link to individual “viewitem.html” pages. Additionally, we frequently used request.form.get to fetch information from our frontend, and then made use of this collected data through an amalgamation of SQLAlchemy and sqlite3 queries, executed by .query() and .execute(), respectively. These main concepts were the foundation of our backend, along with the general theme of working with the information we stored and output in the frontend.
